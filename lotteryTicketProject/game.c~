/*----------------------------------------------------------
			C语言推箱子
	▩		墙				1
	☆		目的地			3
	★		箱子				4
	⊙		箱子到达目的地	3+4=7
	☃		人				5 或 3+5=8 人在目的地显示人	
	空格		路				0
----------------------------------------------------------*/

#include<stdio.h>
#include<stdlib.h>
#include<termios.h>  
#include<assert.h>
#include <string.h>  
#include <unistd.h>  
//关卡数
#define LEVEL 15

//地图
int Map[LEVEL][10][10] =
{
	//	1
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,1,1,1,1,1,0,0,
	0,0,0,1,0,5,0,1,0,0,
	0,0,0,1,0,0,0,1,0,0,
	0,0,1,1,1,4,0,1,0,0,
	0,0,1,0,3,3,3,1,0,0,
	0,0,1,0,4,4,0,1,0,0,
	0,0,1,1,1,0,0,1,0,0,
	0,0,0,0,1,1,1,1,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	2
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,1,0,0,0,
	0,1,0,0,0,3,1,0,0,0,
	0,1,0,1,1,0,1,1,0,0,
	0,1,0,0,4,4,5,1,0,0,
	0,1,0,1,0,0,0,1,0,0,
	0,1,3,0,0,1,1,1,0,0,
	0,1,1,1,1,1,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	3
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,0,0,0,0,
	0,1,0,0,0,1,0,0,0,0,
	0,1,0,5,0,1,0,0,0,0,
	0,1,0,4,4,1,1,1,0,0,
	0,1,1,3,0,3,0,1,0,0,
	0,0,1,0,0,0,0,1,0,0,
	0,0,1,1,1,1,1,1,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	4
	0,0,0,0,0,0,0,0,0,0,
	0,0,1,1,1,1,0,0,0,0,
	0,0,1,0,0,1,1,1,0,0,
	0,0,1,0,4,4,0,1,0,0,
	0,0,1,3,3,3,0,1,0,0,
	0,0,1,0,5,4,0,1,0,0,
	0,0,1,0,0,0,1,1,0,0,
	0,0,1,1,1,1,1,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	5
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,1,1,1,1,0,0,0,
	0,0,1,1,0,0,1,0,0,0,
	0,1,1,5,4,3,1,1,0,0,
	0,1,0,4,4,0,0,1,0,0,
	0,1,0,3,0,3,0,1,0,0,
	0,1,1,1,0,0,0,1,0,0,
	0,0,0,1,1,1,1,1,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	6
	0,1,1,1,1,1,1,0,0,0,
	1,1,0,0,0,0,1,0,0,0,
	1,0,0,0,4,0,1,0,0,0,
	1,0,0,4,4,0,1,0,0,0,
	1,1,1,0,3,1,1,1,1,1,
	0,0,1,1,3,1,0,5,0,1,
	0,0,0,1,3,0,0,4,0,1,
	0,0,0,1,3,0,1,1,1,1,
	0,0,0,1,1,1,1,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	7
	0,0,1,1,1,1,1,1,0,0,
	0,0,1,0,0,0,0,1,0,0,
	0,0,1,0,0,4,0,1,0,0,
	0,1,1,1,1,4,0,1,0,0,
	1,1,0,4,0,4,0,1,0,0,
	1,3,3,3,3,1,0,1,1,0,
	1,0,0,0,0,0,5,0,1,0,
	1,1,0,0,0,0,0,0,1,0,
	0,1,1,1,1,1,1,1,1,0,
	0,0,0,0,0,0,0,0,0,0,
	//	8
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,0,0,0,0,
	0,1,0,0,0,1,1,0,0,0,
	0,1,0,1,0,0,1,0,0,0,
	0,1,5,4,7,3,1,1,0,0,
	0,1,1,0,0,3,0,1,0,0,
	0,0,1,0,4,1,0,1,0,0,
	0,0,1,1,0,0,0,1,0,0,
	0,0,0,1,1,1,1,1,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	9
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,0,0,0,0,
	0,1,0,0,0,1,1,1,1,1,
	1,1,0,0,0,0,4,0,0,1,
	1,0,3,1,0,4,0,0,0,1,
	1,0,3,1,4,1,1,1,1,1,
	1,0,3,5,0,1,0,0,0,0,
	1,1,1,1,1,1,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	10
	0,1,1,1,1,1,0,0,0,0,
	0,1,0,5,0,1,1,1,1,0,
	0,1,0,0,0,0,0,0,1,0,
	0,1,0,4,0,4,4,0,1,0,
	0,1,1,4,1,1,0,0,1,0,
	0,1,0,0,0,1,1,1,1,0,
	0,1,0,3,3,0,0,1,0,0,
	0,1,1,3,3,0,0,1,0,0,
	0,0,1,1,1,0,0,1,0,0,
	0,0,0,0,1,1,1,1,0,0,
	//	11
	0,0,0,1,1,1,1,0,0,0,
	0,1,1,1,0,0,1,1,1,1,
	0,1,0,4,0,4,3,0,0,1,
	1,1,0,1,0,0,3,4,0,1,
	1,0,0,0,1,1,3,1,1,1,
	1,0,0,4,0,0,3,0,1,0,
	1,0,5,0,1,0,0,0,1,0,
	1,0,0,1,1,1,1,1,1,0,
	1,1,1,1,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	12
	0,0,1,1,1,1,1,1,0,0,
	0,0,1,0,0,0,0,1,1,0,
	0,1,1,0,1,1,0,0,1,0,
	0,1,0,4,4,0,1,0,1,0,
	0,1,0,5,4,0,1,0,1,0,
	0,1,0,0,0,0,1,0,1,0,
	1,1,1,1,0,1,0,0,1,0,
	1,0,0,3,3,3,0,1,1,0,
	1,0,0,0,0,0,1,1,0,0,
	1,1,1,1,1,1,1,0,0,0,
	//	13
	0,0,0,0,0,0,0,0,0,0,
	1,1,1,1,0,0,0,0,0,0,
	1,0,5,1,1,1,0,0,0,0,
	1,3,7,0,0,1,1,1,1,1,
	1,3,3,1,4,4,0,4,0,1,
	1,1,0,0,0,0,0,0,0,1,
	0,1,0,1,0,1,1,0,0,1,
	0,1,0,0,0,1,1,1,1,1,
	0,1,1,1,1,1,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	14
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,1,1,0,0,
	0,1,0,0,3,0,3,1,1,1,
	0,1,0,3,0,3,0,3,0,1,
	1,1,1,0,1,1,1,1,0,1,
	1,0,0,5,4,0,0,4,0,1,
	1,0,0,4,4,0,0,4,0,1,
	1,1,1,1,0,0,0,1,1,1,
	0,0,0,1,1,1,1,1,0,0,
	0,0,0,0,0,0,0,0,0,0,
	//	15
	0,0,0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,1,1,0,0,
	0,1,0,0,0,0,0,1,0,0,
	1,1,0,1,1,1,4,1,1,0,
	1,3,4,0,0,0,5,0,1,0,
	1,0,3,3,0,1,4,0,1,0,
	1,3,1,1,0,0,4,0,1,0,
	1,0,0,0,0,1,1,1,1,0,
	1,1,1,1,1,1,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,			
};
//	终端无缓存输入
int getch()  
{  
		int c=0;  
		struct termios org_opts, new_opts;  
		int res=0;  

		res=tcgetattr(STDIN_FILENO, &org_opts);  
		assert(res==0);  
		memcpy(&new_opts, &org_opts, sizeof(new_opts));  
		new_opts.c_lflag &= ~(ICANON | ECHO | ECHOE | ECHOK | ECHONL | ECHOPRT     | ECHOKE | ICRNL);  
		tcsetattr(STDIN_FILENO, TCSANOW, &new_opts);  
		c=getchar();  
		res=tcsetattr(STDIN_FILENO, TCSANOW, &org_opts);  
		assert(res==0);  
		return c;  
}
/*	
	功能：暂停，按任意键退出
	参数：0和1分别打印不同提示信息
*/
void mypause(int message){
	printf("\033[34m");
	if(message == 1)
		printf("\n按任意键进入下一关");
	else
		printf("\n按任意键继续");
	int ch = -1;
	while(1){
		ch = getch();
		if(ch != -1)
			break;
	}
	system("clear");
}
/*	
	功能：绘制地图
	参数：地图数组
*/

void draw_graph(int map[][10]){
	int i = 0,j = 0;
	for( i = 0; i < 10; i++){
		printf("         ");					//地图整体右移
		for(j = 0; j < 10; j++){
			switch(map[i][j]){
				case 1:
					printf("\033[35m▩ ");		//紫色，墙壁
					break;
				case 3:
					printf("\033[34m☆ ");		//蓝色，目的地
					break;
				case 4:
					printf("\033[33m★ ");		//黄色，箱子
					break;
				case 5:
					printf("\033[39m☃ ");		//白，色人
					break;
				case 7:
					printf("\033[32m⊙ ");		//绿色，到达目的地的箱子
					break;
				case 8:
					printf("\033[39m☃ ");		//白色，目的地上的人
					break;
				case 0:
					printf("  ");				//路
					break;
				default:
					break;
			}
		}
		printf("\n");
	}
}
/*	
	功能：绘制游戏界面
	参数：关卡数/地图数组
*/
void view(int level, int map[][10]){
	system("clear");
	printf("\033[36m*************推  箱  子*************\n");
	printf("              \033[34m第 %d 关\n",level+1);
	draw_graph(map);	
	printf("\033[31m\n按键说明：\n");
	printf("\033[34m  上(↑ ) ：w      \033[34m  回  退 ：r\n");
	printf("\033[34m  下(↓ ) ：s      \033[34m  重  置 ：b\n");
	printf("\033[34m  左(← ) ：a      \033[34m  下一关 ：n\n");
	printf("\033[34m  右(→ ) ：d      \033[34m  选  关 ：c\n\n");
	printf("\033[31m按'0'退出游戏\n");
}
/*	
	功能：检查是否完成关卡
	参数：地图数组
	返回值：完成返回 0,未完成返回 1
*/
int end_check(int map[][10]){
	int i = 0,j = 0;
	for( i = 0; i < 10; i++){
		for( j = 0; j < 10; j++){
			if(map[i][j] == 4){			//完成后数组里没有箱子4,到达目的地的箱子为7
				return 1;
			}
		}
	}
	return 0;
}
/*	
	功能：移动人物时改变数组元素
	参数：地图数组/i,j表示人的位置/方向键
*/
char change(int map[][10], int i, int j, char ch){
	int _i = 0, _j = 0;
	switch(ch){
		case 'w':
			_i = -1;
			break;
		case 'a':
			_j = -1;
			break;
		case 's':
			_i = 1;
			break;
		case 'd':
			_j = 1;
			break;
		default:
			break;
	}
	if(map[i+_i][j+_j] == 0 || map[i+_i][j+_j] == 3){				//移动方向的第一格为路或是目的地时
		map[i+_i][j+_j] += 5;										//移动方向的第一格加上人的值 5
		map[i][j] -= 5;												//原位置减去人的值 5
		return ch;													//该操作未移动箱子，返回小写的方向键
	}
	else if(map[i+_i][j+_j] == 4 || map[i+_i][j+_j] == 7){			//移动方向的第一格有箱子时
		if(map[i+2*_i][j+2*_j] == 0 || map[i+2*_i][j+2*_j] == 3){	//移动方向的第二格为路或是目的地时，可移动
			map[i][j] -= 5;											//原位置减去人的值 5
			map[i+_i][j+_j] += 1;									//显示人，4+1=5或者7+1=8
			map[i+2*_i][j+2*_j] += 4;								//移动方向的第二格加上箱子的值 4
			return ch-32;											//该操作移动了箱子，返回大写的方向键
		}
		return 0;													//该操作未改变位置则返回 0
	}
	else{
		return 0;
	}
}
/*	
	功能：回退操作
	参数：地图数组/i,j表示人的位置/记录每步操作的方向键
*/
void rechange(int map[][10], int i, int j, char ch){
	int _i = 0, _j = 0;
	switch(ch){
		case 'w':
		case 'W':
			_i = 1;
			break;
		case 'a':
		case 'A':
			_j = 1;
			break;
		case 's':
		case 'S':
			_i = -1;
			break;
		case 'd':
		case 'D':
			_j = -1;
			break;
		default:
			break;
	}
	map[i+_i][j+_j] += 5;								//方向键相反方向的第一格加上人 5
	map[i][j] -= 5;										//原位置减去人 5
	if(ch >= 97){										//如果方向键为小写字母，则表示之前该操作未移动箱子，直接退出
		return;
	}else{												
		map[i-_i][j-_j] -= 4;							//方向键方向的第一格减去箱子 4
		map[i][j] += 4;									//原位置加上箱子 4
	}
}
/*	
	功能：操作输入函数
	参数：地图数组/记录每步操作的方向键的字符串/步数、
	返回值：0 回退 /1 重置 /2 下一关 /3 选关 /4 退出
*/
int key_down(int map[][10], char* str, int* step){
	int i = 0, j = 0;
	char ch = 0;
	//	查找出人的位置
	for(i = 0; i < 10; i++){
		for(j = 0; j < 10; j++){
			if(map[i][j] == 5 || map[i][j] == 8){
				break;
			}
		}
		if(map[i][j] == 5 || map[i][j] == 8){
			break;
		}
	}
	char key = getch();		//获取输入的方向键
	switch(key){
		case 'w':
		case 'W':
		case 'a':
		case 'A':
		case 's':
		case 'S':
		case 'd':
		case 'D':
			if(key < 97){
				key += 32;					//将方向键全部转化为小写字母，作用见change函数注释
			}
			else{}
			ch = change(map,i,j,key);		//调用人物移动函数
			if(*step < 10000){				//防止步数超过记录步数的数组容量
				if(ch != 0)					//该操作有改变人的位置则记录操作，反之不记录
					str[(*step)++] = ch;
				else{}
			}else{
				printf("\033[31m超出步数上限\n");
				return 4;
			}
			break;
		case 'r':
		case 'R':
			if(*step > 0){						//步数大于0才能回退
				rechange(map,i,j,str[*step-1]);	//调用回退函数
				str[*step-1] = 0;				//记录该步骤的元素清除
				(*step)--;						//步数减去1
			}
			else{}
			return 0;
		case 'b':
		case 'B':
			return 1;
		case 'n':
		case 'N':
			return 2;
		case 'c':
		case 'C':
			return 3;
		case '0':
			return 4;
		default:
			break;
	}
	return 0;
}

int main(){
	int level = 0;						//当前关卡
	int res = 0, num = 0;
	int _map[LEVEL][10][10] = {0};		//地图备份数组
	char str[10000] = {0};				//记录有效操作方向的字符串
	int step = 0;						//记录有效步数
	memcpy(_map,Map,LEVEL*10*10*sizeof(int));
	while(1){
		while(end_check(_map[level])){									//通关时退出循环
			view(level,_map[level]);
			res = key_down(_map[level],str,&step);
			switch(res){
				case 1:
					memcpy(_map[level],Map[level],10*10*sizeof(int));	//重置当前关卡
					memset(str,0,1000*sizeof(char));					//重置操作记录
					break;
				case 2:
					if(level == LEVEL - 1){
						printf("\033[31m当前关卡已为最后一关\n");
						mypause(2);
						}
					else{
						memcpy(_map[level],Map[level],10*10*sizeof(int));
						memset(str,0,1000*sizeof(char));
						level++;										//下一关
					}
					break;
				case 3:
					memcpy(_map[level],Map[level],10*10*sizeof(int));	//重置选关前的关卡
					memset(str,0,1000*sizeof(char));
					printf("\033[34m请输入选择的关卡(1~15)：");
					scanf("%d",&num);
					while(getchar() != 10);
					if(num > 0 && num <= LEVEL){
						level = num -1;
					}
					else{
						printf("\033[31m输入的关卡不存在\n");
						mypause(2);
					}
					break;
				case 4:
					return 0;
				default:
					break;
			}
		}
		view(level,_map[level]);
		printf("\033[31m\n恭喜过关\n");
		if(level++ > LEVEL-1){
			printf("\033[31m恭喜您已通过全部关卡\n");
			mypause(0);
			break;
		}else{
			mypause(1);
		}
		memset(str,0,1000*sizeof(char));
	}
	
	return 0;
}
