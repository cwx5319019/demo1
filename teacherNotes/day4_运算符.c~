/*
	运算符的基础:运算符的大致分类，我们通过参与运算的元素的个数进行分类，有单目运算符，双目运算符，三目运算符
		① 算数运算符:+,-,*,/,%,都属于双目运算符
			（1）除法和取余运算中，除数不能为0。
				一旦除数为0，运行的时候就会出现浮点数例外，核心已转储
			（2）取余运算中，参与运算的两个数据，都必须是整型数据
				问题在于，在实际编程当中，总是会出现，需要两个浮点数参与取余运算的情况，这个时候，就应该对两个浮点数进行强制数据类型转换(强转),将他们暂时的转换成整型。
				如何强转:在等待强转的数据前面加上一组(),()中写上强转的目标类型，那么，含有强转的表达式整体就会变成目标类型
		这里出现了一个表达式的概念：由运算符构成的算数表达式，他总是能对应一个具体的值，例如 2+3 就是一个表达式，他对应的就是整型5，那么(int)3.14也是一个表达式，他对应的就是整型3
		
//---------------------
#include<stdio.h>

int main(){

	double a = 5;
	double b = 2;
	printf("%d\n",(int)a%(int)b);

	printf("%d\n",2+'0');
	return 0;
}
//--------------------------

		所以，我们getchar()也是一个表达式，他对应的值就是字符类型的从终端获取到的数据
			(3) 在算数运算符当中，如果有两个不同类型的数据参与到一个算数运算当中，那么运算结果的类型取精度较高的类型
		② 赋值运算符，属于双目运算符，有:=,+=,-=,*=,/=以及各种双目运算符的等号
		赋值运算符的概念为：读取等号右侧的值，然后写入等号的左侧。那么整个赋值运算符的表达式的值，应该就是等号左侧的值
		各种双目运算符的等号，我们称为复合赋值运算符：
		复合赋值运算符的含义，举例说明：a-=b 就可以简单的看做 a = a-b;
			所以，复合赋值运算符的含义就是：读取左侧运算右侧的运算结果后，在写入到左侧
		③ 比较运算符:<,>,<=,>=,==,!=
			比较运算符属于双目运算符
			由比较运算符构成的表达式，所对应的值，只有0和1
			举例说明: 3>2 由于这个表达式成立，所以他的值就是1，反过来，3<2这个表达式不成立，所以对应的值就是0
			
//-------------------------
#include<stdio.h>

int main(){
	int a = 4,b = 3,c = 2;
	printf("%d\n",a>b>c);
	return 0;
}
//------------------------------
			在计算机中成立和不成立：
				计算机在判断是否成立的时候，判断0为不成立，非0为成立
				计算机在表述是否成立的时候，以0表示不成立，以1表示成立
			浮点型数据的大小比较方式：在比较两个浮点型数据的时候，必须确定他两的精度
			例如：double a = 3.1234567;
				double b = 3.1235567;
			从字面上克制，a在小数点后4的情况下，就会比b小，4位之前和b一样大，那么此时，就应该将精度精确到小数点后4位：a-b>-0.0001 && a-b<0.0001
			
//--------------------------------
#include<stdio.h>

int main(){
	double a = 3.1233567;
	double b = 3.1234567;
	printf("%d\n",a-b<=-0.001);//b-a>0.0001在小数点后4为的精度范围内，b比a大的表达形式，a-b>-0.001 && a-b<0.001在小数点后3位的精度范围内，b和a相等的表达形式
	//一般而言，浮点数在比较谁大谁小的时候，很少要求精度，因为通常情况下，整数位就比较出大小了，只有在比较两者是否相等的情况下，会严格要求精度。
	return 0;
}
//-----------------------------------
		④ 逻辑运算符
			逻辑与:&& ，他是一个双目运算符，参与到逻辑与运算中的两个数据/表达式，只有当他们全都成立的时候，那么整个逻辑与表达式，才成立
			逻辑或:||，他是一个双目运算符，参与到逻辑或运算中的两个数据/表达式，只要其中有一个成立，那么整个逻辑或表达式成立
			逻辑非:!，他是一个单目运算符，对任何一个数据/表达式进行取非操作，那么就会让他的结果反转。非假为真，非真为假

//--------------------------------------
#include<stdio.h>

int main(){

	printf("%d\n",1>0 && !2>-1);  //!的优先级大于 >
	return 0;
}

//----------------------------------------

		⑤ 三目运算符:顾名思义，有3个数据/表达式参与运算
			表达式: 	表达式1？表达式2：表达式3
			首先‘？’代表判断表达式1是否成立，如果成立，则整个三目运算符表达式对应的值就是表达式2，如果不成立，则对应的值就是表达式3
		⑥ 自增运算符：++和--
			自增运算符分为 前++和后++
			举例：int a = 1;
			那么就有a++和++a两种自增方式，无论是哪一种自增方式，最终都会换算成表达式 a = a+1,所以最终的结果，a都会变成2。
			但是 a++ 和 ++a 是有区别的：
			后++：先赋值后运算,先将a的值赋值给a++表达式本身，然后a再做自增1运算
			前++：先运算后赋值,先运算就代表先做自增1的运算，然后将运算后的结果赋值给 ++a 这个表达式本身
			
//-------------------------------
#include<stdio.h>

int main(){
	int a = 1,b = 1;
	printf("%d\n",a++);//1
	printf("%d\n",++b);//2
	printf("%d\n",a);//2
	printf("%d\n",b);//2
	return 0;
}

//-------------------------------

		⑦ 位运算符：位运算符只针对二进制数上的每一位的0或者1进行运算
			按位与 & :参与按位与运算的两个数据上的每一位，全都为1，则运算结果为1，如果有0则运算结果为0
			按位或 | :参与按位或运算的两个数据的每一位，有1则运算结果为1，全0则运算结果为0
			按位取反 ~:是个单目运算符，参与按位取反的数据，所有位的数据都会取反，也就是0变1,1变0,按位取反的运算规则基本符合 先+1再取相反数
			以上3个位运算符，在系统的底层操作当中尤为重要：为了保证系统底层的功能开关/权限开关不会重复打开或者重复关闭，系统在做打开关闭的操作的时候，并不是使用加法打开或者减法关闭，而是使用按位或(|)打开,按位与取反(&~)关闭
			按位异或：^ 双目运算符，参与按位异或的两个数据，每一位上的值，相等则为0，不等则为1

			左移和右移:<<,>>,双目运算符，举例说明，1左移2位，1<<2

		结合以上那么多的位运算符，我们有两个公式:
		a |= (1<<n);  //点灯
		a &= ~(1<<n); //灭灯
		
//-----------------------------------
/*
#include<stdio.h>

int main(){
	int a = 8,b = 15;
	printf("%d\n",a = a | (1<<2));
	printf("%d\n",b = b & ~(1<<2));

	//0000 1111

	//0000 1011

	return 0;
}
*/


//------------------------练习-----------------


/*
	从键盘输入3个随机数，然后按照从小到大的方式依次输出
*/
/*
#include<stdio.h>
int main(){
	int a = 0,b = 0,c = 0;
	printf("请输入要比较的3个数的大小:");
	scanf("%d %d %d",&a,&b,&c);
	while(getchar()!=10);
	int smaller = (a<b)?a:b;
	int min = (smaller<c)?smaller:c;

	int bigger = (a>b)?a:b;
	int max = (bigger>c)?bigger:c;

	int mid = a + b + c - max - min;
	printf("%d %d %d\n",min,mid,max);
	return 0;
}

*/

//-----------------------文件权限管理

/*
#include<stdio.h>

int main(){
	//chmod u+r demo.c
	int u = 0;
	//打开可读权限
	u = u|4;
	printf("u = %d\n",u);

	//打开可写权限
	u = u|2;
	printf("u = %d\n",u);

	//打开可执行权限
	u = u|1;
	printf("u = %d\n",u);

	u = u|4;
	printf("u = %d\n",u);

	u = u&~4;
	printf("u = %d\n",u);

	u = u&~2;
	printf("u = %d\n",u);

	u = u&~1;
	printf("u = %d\n",u);

	u = u&~4;
	printf("u = %d\n",u);
	return 0;
}
*/

//-----------------------
/*
	假设现在有一个整型数 int a = 12345,要求，将他变成54321后，输出到终端上。使用算术运算符和赋值运算符即可实现。
*/
/*
#include<stdio.h>

int main(){
	int a = 12345;
	int five = a%10 * 10000;//5
	int four = a/10%10 * 1000;//4
	int three = a/100%10 * 100;//3
	int two = a/1000%10 * 10;//2
	int one = a/10000;//1
	a = one+two+three+four+five;
	printf("a = %d\n",a);
	return 0;
}
*/

//------------------------------
/*
	从键盘输入2个非0整型数，x和y，让他作为一个点的x，y坐标，在不适用任何判断语句的情况，计算出该点位于第几象限
	使用比较运算符，逻辑运算符和赋值运算符即可实现
	4个象限当中，第1到3象限，x和y总共为负数的数量为0,1,2，第四象限单独计算
*/
/*
#include<stdio.h>

int main(){
	int x = 0,y = 0;
	printf("请输入x，y轴坐标:");
	scanf("%d %d",&x,&y);
	while(getchar()!=10);
	int pos = (x<0) + (y<0) + 1 + (x>0&&y<0)*2;
	printf("该点处于第%d象限\n",pos);
	return 0;
}
*/


//------------------各种++ --大杂烩
/*
#include<stdio.h>

int main(){

	int a = 2,b = 3;
	a*=	a++ + 	b++ + 	a++;
	//4*=	2		3		3 a = 32
	b+=	a++ + 	b +	 b++;
	//5+=	32 +	4 + 4
	printf("a = %d,b = %d\n",a,b);

	int a = 2,b = 3,c = 4,d = 5, e = 6;
	a+=5*=c-=d%=e/=2;
	return 0;
}
*/

//--------------------------
/*
	使用3种方法，交换两个变量的值
		① 中间变量法
		② 算数运算法
		③ 位运算法(按位异或)
*/
#include<stdio.h>

int main(){
	int a = 5,b = 10;
	int* pa = &a;
/*
	int temp = a;
	a = b;
	b = temp;
*/
/*
	a = a + b;
	b = a - a;
	a = a - b;
*/

// 0101  a 
// 1010  b
// 1111  ^

//所以  规律就是 a ^ (a^b) 就是b    b ^ (a ^b)就是a

	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
/*
	这里有2个地方需要注意的：
		①使用第三方变量法，效率最低，但是最稳定
		使用算数运算符或者按位异或的方法做变量交换的话，一定注意参与交换的两个数据不能是同一个数据
		②效率最高的位运算符，因为即使是算数运算符的操作，他最终还是会转换成位运算符去实现(算数运算符的底层就是依靠位运算符实现的)
*/
	printf("a = %d,b = %d\n",a,b);
	return 0;
}
