/*
	可变参函数：顾名思义，参数的数量可以随时改变的函数。
	printf和scanf就是两个典型的可变参函数。
	可变参函数通常情况下，第一个参数必须是固定参数，然后人为的约定，第一个参数直接或者间接的决定到底有多少个可变参。这是可变参函数的声明规则

	如何声明一个可变参函数：
		函数返回值类型 + 函数名(固定参数，...)
*/
/*
//-----------------------------------
#include<stdio.h>
#include<stdarg.h>

	//va_list 是一个指针变量类型，他相当于char*，因为他的模块大小是1个字节，但是是否为char*不清楚


void func(int num,...){
	va_list p;
	va_start(p,num);//这个函数会将p指向可变参数的第一个参数,也就是固定参数num的下一个参数
	printf("%d\n",va_arg(p,int));//这个函数会将p当前指向参数，以基础类型为int类型取值,也就是说会准确的读取int数据所占据的4个字节内存并取值。然后再将p指向下一个可变参的地址，最后将从地址上取出来的值，返回给va_arg表达式
	printf("%d\n",va_arg(p,int));
	printf("%d\n",va_arg(p,int));
	printf("%d\n",va_arg(p,int));
	va_end(p);
}

int main(){
	func(500,400,300,200,100);
	return 0;
}
*/
//---------------------------
/*
	编写一个函数，它能够传入随意数量的整型数，函数功能为计算所有传入参数的和
*/
/*
#include<stdio.h>
#include<stdarg.h>

int func(int num,...){
	va_list p;
	va_start(p,num);
	int i = 0;
	int res = 0;
	for(i=0;i<num;i++){
		res = res + va_arg(p,int);
	}
	va_end(p);
	return res ;
}

int main(){
	int res = func(6,1,2,3,4,5,6);
	printf("res = %d\n",res);
	return 0;
}
*/

//-----------------------------------------------------




/*
	内存的概念：
		由于内存是由高低电平来表示二进制中的1和0以达到运算中告诉存储的目的。所以，内存最大的优点，运算速度快。最大的缺点就是一旦断电，则所有数据全都丢失。
		这个优缺点是相对于硬盘而言的：硬盘就是反过来，访问速度慢，但是断电数据依旧存在。
	
	linux系统中的内存大致可以分为以下几类：
		① 栈内存:
			1:先进后出
			2:自动申请自动释放
				所有在栈空间上产生的变量，都会自动在栈空间上申请一片内存空间。我们平时所说的声明变量，都是在栈空间上申请的空间。一旦该变量生命周期结束，该变量在栈空间上所申请的空间就会被系统自动回收。也就是说该变量所属的空间不再归用户所有。
			用户对于所有不被自己所拥有的地址，都会将他们称为野指针。
			所有针对野指针的修改/访问，一旦运行，就会段错误
			生命周期：通常情况下，一个变量的生命周期默认与作用域同步。
			
//---------------------------------
#include<stdio.h>

int* func(int* b){
	int a = 5;//0x21
	int* pa = &a;
	//pa = b;
	return pa;//return &a;
}

	//无论是返回pa也好，还是返回&a也好，都是返回一个局部变量地址，都属于非法操作。所以，无论如何神操作，都不允许返回一个栈空间局部变量的地址

int main(){
	int b = 5;
	int* pa = func(&b);
	printf("%d\n",*pa);
	return 0;
}
//----------------------------------------
		② 静态存储区:
			独立于栈空间的另外一段空间，他的特点就是，当程序开始之前，静态存储区就已经存在，当程序结束之后，静态存储区才会消失
			所以，当一个数据存放到静态存储区之后，这个数据就可以在整个程序运行过程中，一直存在，无论变量名还是地址，都可以有效的访问到该数据(注意，如果通过变量名访问一个静态变量，依旧需要注意作用域)
			当使用变量名访问静态变量的时候：如果这个静态变量实在某一个特定的作用域中声明的话，虽然他的生命周期在整个程序中永久存在，但是他的作用域却被限定在了声明的作用域中，所以想要全局访问它的话的，只能通过指针
			如果一定要通过变量名的方式，全局访问一个静态变量的话，我们应该将这个静态变量声明在所有的{}以上，我们把这样的一个静态变量称为全局变量
			声明全局变量，不用加任何关键字，就会默认在静态存储区申请空间
			如果想在一个作用域内，声明静态变量的话，需要在声明的前面加上关键字static。
			static的作用：延长生命周期，限制作用域
			
//----------------------------------------
#include<stdio.h>


void func(){
	static int a = 0;
	a++;
	printf("%d\n",a);
}

int main(){
	for(int i=0;i<10;i++){
		func();
	}
	return 0;
}
//--------------------指针计数和静态变量计数对比

#include<stdio.h>

void insert(int* count){
	(*count)++;
}

void Remove(int* count){
	(*count)--;
}

void _insert(){
	static int count = 0;
	count++;
	printf("insert:%d\n",count);
}

void _Remove(){
	static int count = 0;
	count--;
	printf("remove:%d\n",count);
}

int main(){
	int count = 0;
	insert(&count);
	insert(&count);
	insert(&count);
	insert(&count);
	insert(&count);
	Remove(&count);
	Remove(&count);
	_insert();
	_insert();
	_insert();
	_Remove();
	_Remove();
	printf("容器中还有%d个数据\n",count);
	return 0;
}
//-------------------------------------------------
		③ 堆内存
		④ 常量存储区:存放所有常量的地方
*/
