/*
	静态存储区:
		静态存储区的生命周期从主函数开始之前直到主函数结束之后。
		所以只要存到静态存储区中的数据，都会在整个程序中一直存在。
		在一个特定的作用域中，想要将一个局部变量声明成静态局部变量的话，就应该在前面加上static关键字
		static的作用：延长生命周期，限制作用域。
			只要在静态存储区中的数据，当重新声明一个静态变量的时候，系统都会优先根据作用域去寻找同一个作用域下同名的静态变量，如果找到了，则直接引用。如果没找到，则声明一个新的静态变量

	静态存储区中，全局变量的特点：
		程序的分文件写法：我们可以将一个.c文件，分成若干个.c文件来编写，可以按照身份分类，也可以按照功能分类。然后注意，所有.c文件都需要包含同一个自定义的头文件，该头文件中写有所有该程序所需要的头文件以及函数声明。当需要编译刚刚编写的所有.c文件的时候，只需要将所有.c文件名全都写上，并使用空格隔开就能成功编译该程序
	包含头文件时，“”和<>的区别：
		<> 只会到系统默认的环境变量中寻找头文件，不存在则编译错误。系统默认的环境变量在 /usr/include
		"" 会现在当前目录下寻找同名的头文件，如果不存在，再去系统默认的环境变量中寻找头文件
*/
/*
	总结函数份文件写法：主函数已经其他一些入口函数都写在main.c中。其他功能函数全都写在其他的.c文件中。所有.c文件，只需要包含一个自定义的头文件，该头文件包含该程序所需要的所有系统头文件，已经所有自定义的函数的声明
	static 的另一个作用：限定作用域
	在一个.c文件中，我们如果想要引用另外一个.c文件中的全局变量的话，2中方式
	extern 类型 + 全局变量名
	或者没有extern
	extern的作用为强制引用外部全局变量，如果外部没有同名全局变量的话，该语句失效
	没有extern的情况下，先尝试引用外部全局变量，如果外部没有全局变量的话，则声明该全局变量
	全局变量在未初始化的情况下，默认初始化为0
*/
/*
	静态函数:在函数声明的时候，加上static表示该函数为静态函数。静态函数的特点
	① 被限制只能在声明的文件中调用
	② 一般函数而言，在调用的时候，会在栈空间上开辟新的空间来执行函数。如果函数没有结束运行之前，继续调用的话，会再次开辟新的空间来运行函数。
		而静态函数，他只会在静态存储区中开辟一次空间，之后无论什么情况下，都会反复使用这段已经开辟好的静态存储区的空间

	普通函数，静态函数，内联函数和带参宏的区别
		带参数：形式类似函数，但是带参宏参与编译的不是带参宏，而是被替换的代码，所以带参宏允许传入数据类型
		内联函数：在函数声明前面加上inline可以声明内联函数(只有标准c语言中可以声明内联函数c86)，内联函数的特点(内联函数和带参宏很像)：普通函数发生调用的时候，会发生控制转移，代码的运行从函数调用处直接转移函数的定义处。而内联函数发生调用的时候，会直接将内联函数的定义部分，嵌套到函数的调用处下面。所以内联函数的运行，完全依靠主函数的栈空间
*/
/*
	c语言程序的调试工具:gdb
	怎么使用gdb来调试一个c语言的代码：
		① 在编译的时候，在编译语句的末尾加上 -g 使生成的可执行文件，带有可调式属性
		② gdb + 可执行文件名(./a.out)

	gdb 的使用方法：
		① r : 直接运行程序，程序会在错误处中断或者直接运行结束
		当有些错误发生在库函数当中(也就是传入的参数有问题，导致库函数运行出错)，由于库函数在ubuntu中不存在源码，所以当库函数发生错误的时候，gdb肯定不能准确的定位到错在哪，但是会提示错误发生在哪个函数中。
		当然，我们还可以通过另外一种形式，去定位错误
		② b : 设置程序的断点 b + 行号/自定义函数名 就能将程序打断在想要的地方。注意，这个断点方式，只会将断点设置在main函数所在的.c文件
			如果想要将断点设置在其他的.c文件中应该这么写:
				b + .c文件名:具体断点
		③ n : 从当前断点行数，执行下一条语句。
			注意：无论是通过断点停下来的语句，还是通过n逐步执行的语句，所有在当前行停止的代码，都默认没有执行当前行
		④ s : 进当前行的函数(只能进入自定义函数，库函数无法进入)
		⑤ l : 查看当前行周围的代码
		⑥ c : 从当前行全力执行剩余代码
		⑦ q : 退出gdb
*/
/*
	递归函数：
		在函数内部，再次调用本身的形式，就是递归函数
	递归函数的三要素：
		① 自己调用自己
		② 要有明确的退出条件
		③ 每一次递归，必须逐渐趋近于退出点

	想要写好一个递归的话，必须先了解递归的基本思路
		通常情况下，我们遇到一个复杂的问题的时候，我们会将这个问题分解一个简单的问题去处理，如果这个简单的问题依旧复杂，那么我们可以将这个问题再次分解，直到分解到这个问题的结果一目了然为止。然后通过这个最底层的解，逐一向上解决问题。
*/
/*
	在实际运用过程当中，递归函数通常情况下都是对操作的递归，而不是使用递归进行运算。递归的运算，其实会比循环复杂。
*/
/*
	递归和循环的区别：
		
	循环势必造成时间复杂的上升，但是空间复杂度几乎为0
	而递归势必造成空间复杂度的上升，而时间复杂度取决于算法问题

	注意：在递归函数当中，严禁使用静态局部变量,因为，在递归函数内部使用静态局部变量的话，第一次调用递归函数能够实现计算结果，但是第二次开始，结果就会有错误
*/

//------------------------递归例题-------
/*
#include<stdio.h>

int func(int num){
	if(num==1){return 1;}
	return func(num-1)+num;
}

	//func(1) = 1
	//func(2) = func(2-1) + 2 = func(1) + 2 = 3
	//func(3) = func(3-1) + 3 = func(2) + 3 = 6
	//func(4) = func(4-1) + 4 = func(3) + 4 = 10
	//func(5) = func(5-1) + 5 = func(4) + 5 = 15


//	1+1/2+1/3+1/4+....+1/n


double f2(int n){
	if(n==1){return 1.0;}
	return f2(n-1) + 1.0/n;
}

int main(){
	printf("%g\n",f2(4));
	return 0;
}

*/
//---------------------递归练习----

/*
	1:使用递归解决猴子吃桃的问题
	2:使用递归解决 1/1-1/3+1/5-1/7+...-1/99+1/101
	3:使用递归解决斐波那契数列第n项值的问题
*/
/*
#include<stdio.h>

int f1(int n){
	if(n==1){return 1;}
	return (f1(n-1)+1)*2;
}

double f2(int n){
	if(n==1){return 1.0;}
	return f2(n-2) + 1.0/n * ((n/2%2==0)?1:(-1));
}

int f3(int n){
	if(n==1||n==2){return 1;}
	return f3(n-2) + f3(n-1);
}

int main(){
	printf("%d\n",f4(1));

	printf("%d\n",f4(1));
	return 0;
}
*/

//--------------职坐标 四舍五入------------
/*
#include<stdio.h>

double func(double num,int n){//12.3456 2
	int i = 0;
	for(i=0;i<n;i++){
		num*=10;
	}
	//num = 1234.46
	int temp = num + 0.5;
	num = temp;
	for(i=0;i<n;i++){
		num/=10;
	}
	return num;
}

int main(){
	double num = 0;
	int n = 0;
	scanf("%lf %d",&num,&n);
	while(getchar()!=10);
	num = func(num,n);
	printf("num = %g\n",num);
	return 0;
}
*/

/*
	数组：由同一种类型的数据，组合而成的数据结构。或者可以将数组理解成，能够存放相同数据类型的容器，该容器的类型完全取决于所存放的数据的类型
	从内存角度考虑，什么是数组？连续的内存模块，每一个内存模块到底多少，取决于数组的类型
	数组存放数据的时候，已经默认好坐标位置了，所以存放数据的时候，无需手动设定坐标位置

	如何声明一个数组：数组类型  + 数组名[数组容量] = {具体存放的数据，多个之间使用,隔开}
	声明 整型数组 arr[5]为例
	① int arr[5] = {1,3,5,7,9},声明数组arr，并且申请20个字节的内存空间，并且分别对每一个int模块的地址赋值成1,3,5,7,9
	② int arr[5] = {1},声明数组arr，并且申请20个字节内存，并且将第0个模块的地址赋值成1，剩余模块的地址赋值成0
	③ int arr[5] = {0} ,声明数组arr，并且申请20个字节内存，并且所有int模块全都赋值成0
	④ 如果声明数组的时候，最大容量没有填写，那么此时，必须对数组做定义
	⑤ 如果使用变量来声明数组的最大容量的时候，那么次时候，不能对数组做定义

	其实，数组的声明及定义方式，最常用的就是第③个
*/
/*
	数组名的特性：
		数组名单独出现的时候，他代表一个指针，指向了该数组首元素地址的指针
		当数组名配套sizeof或者&符号的时候，此时数组名就会代表整个数组
	数组名作为指针的时候，注意他是一个指针常量(就是该指针是一个常量，不能更改指向)
		当一个指针指向一个数组名之后，该指针就能完全用来代表该数组，直到该指针指向其他地方为止。

//------------------------------		
#include<stdio.h>

int main(){
	int arr[5] = {1,3,5,7,9};
	int brr[5] = {0};

	printf("arr = %p\n",arr);
	printf("arr+1 = %p\n",arr+1);
	printf("&arr = %p\n",&arr);
	printf("&arr+1 = %p\n",&arr+1);
	printf("%lu\n",sizeof(arr));
	int* pa = 0;
	int a = 5;
	pa = arr;     
	pa = brr;
	pa = &a;
	return 0;
}
//-------------------------------
*/
/*
	如何访问一个数组中的元素：
	使用 :数组名[下标位置] 来访问该“下标位置”所代表的内存存放的数据
		注意：下标位置从0开始
*/
/*
	所有的数据结构当中，总是存在以下几种操作
		增，删，改，查，排，遍历
*/

#include<stdio.h>

void print_data(int* arr,int len){
	int i = 0;
	for(i=0;i<len;i++){
		printf("%d ",arr[i]);
	}
	printf("\n");
}

int find_data(int* arr,int data,int len){
	int i = 0;
	for(i=0;i<len;i++){
		if(arr[i] == data){
			return i;
		}
	}
	return -1;
}

void insert_data(int* arr,int* len){//{1,3,5,7,9}
	int data = 0;
	printf("请输入要添加的数据:");
	scanf("%d",&data);
	while(getchar()!=10);

	int res = find_data(arr,data,*len);
	if(res>=0){
		printf("该数据已存在\n");
		return ;
	}
	arr[*len] = data;
	(*len)++;
}

void update_data(int* arr,int len){
	int data = 0;
	printf("请输入要修改的数据:");
	scanf("%d",&data);
	while(getchar()!=10);
	int res = find_data(arr,data,len);
	if(res==-1){
		printf("查无此数\n");
		return ;
	}
	printf("请输入修改后的数据:");
	scanf("%d",&data);
	while(getchar()!=10);
	arr[res] = data;
}

int main(){
	int arr[5] = {0};
	int len = 0;
insert_data(arr,&len);
insert_data(arr,&len);
insert_data(arr,&len);
insert_data(arr,&len);
insert_data(arr,&len);
	print_data(arr,len);
	
	update_data(arr,len);
	print_data(arr,len);
	return 0;
}
