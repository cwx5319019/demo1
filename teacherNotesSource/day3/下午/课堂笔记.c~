/*
	c语言中的数据类型:不同的数据类型，在内存中占据的内存大小是不同的，就会造成该数据类型的取值范围是不一样的
	通常情况下，有符号的数据类型，最高位为符号位，0代表正，1代表负。剩下的都为数据位。
	那么二进制数如何向十进制数转换:
		① 短除法
		② 数零法
	以 1 个字节为例，1个字节的数据，他的最大值：2^7-1,最小值是-2^7
	
//------------------------
#include<stdio.h>

int main(){
	char a = 400;//127+256=383,400-383 = 17,-128+16
	unsigned char b = 500;//1111 1111 -> 2^8-1 = 256-1 = 255
	//500-255 = 245,0+244
	printf("%d\n",a);
	printf("%d\n",b);
	return 0;
}
//------------------------------------

	那么，为什么1111 1111转换成十进制是-1而不是-128。因为计算机在比较数据大小的时候，永远只能比较他们的绝对值
	为了实现负数大小，与绝对值大小的统一，我们为计算机引入了补码的概念。计算机中所有的数据，都是以二进制补码的形式存在的
	源码：有十进制数通过短除法或者数零法转换出来的二进制数，就是这个数的源码
	反码：在源码的基础上，符号位不变，其他位取反
	补码：在源码的基础上+1
	注意：正数的补码就是源码本身，负数的补码才需要通过反码来计算
	注意：当使用二进制计算，得到的结果是一个负数的时候，这时候肯定是补码，此时不能直接通过数零法转换成十进制，必须先得到源码，才能转换。对补码再求一次补码，就会获得他的源码
	当一个数据的取值，超过了他的最大值后，就会从最小值开始，重新取值。反过来一样，当他的取值超过了他的最小值后，就会从最大值开始重新取值。
	在代码中，我们使用正常的表达方式，来书写一个十进制数，使用0开头的数，来书写一个八进制数，使用0x开头的数，来书写一个十六进制的数
	其中八进制数在系统底层中尤为重要，我们到运算符的时候，再来分析八进制数
	C语言中的数据类型，大致分为以下几类：
		① 整型:所有整数数据，都会存放于整型类型的变量中
			分为：
				长整形:long,占8个字节，使用%ld进行格式占位
				普通整型:int,占4个字节，使用%d进行格式占位
				短整型:short,占2个字节，使用%d进行格式占位
		② 字符型:所有单一的字符数据(包含，但不限于，a~z,A~Z,0~9,!?之类的)，所有单一的字符必须使用''括起来
			使用char表示字符型数据，在内存中占1个字节，使用%c进行格式占位
			为了表示那些不可见字符，我们会使用转义符来表示。
			同样的，我们还可以使用另一种方式来表示不可见字符：
				我们人为的为每一个字符，都编排了一个号码，这个号码就是ASCII码。所以，在printf中，如果使用%d输出一个字符类型的变量，最终输出的是该字符的ASCII码。但是，注意，在scanf中，只能使用%c进行格式占位
			ASCII码使用总结: 大小字母的ASCII码+32，就会变成对应的小写字母，小写字母-32就会变成对应的大写字母。数字字符-48，就会变成对应的整型数
		③ 浮点型:所有带有小数的数据，都存放于浮点型变量中
			浮点型数据分为：
				单精度浮点型:float,占4个字节的内存，使用%f进行格式占位
					最高位为符号位，2~9位为指数位(这里实际上存放的2进制数都是指数，2的指数)，10~32位为尾数位
				双进度浮点型:double,占8个字节，使用%lf进行格式占位
					最高位为符号位，2~12位为指数位，13到64位为尾数位
				在printf的时候，我们可以使用%.nlf,来表示打印小数点后n位，并且在显示上四舍五入
				也可以使用%g来打印所有的有效位
				浮点型数据注意事项:
					1:浮点型数据不参与位运算(针对每一位0或者1进行的基础运算)
					2:浮点型数据由于存在精度偏差，所有，在两个浮点型数据比较大小的时候，一定要明确精度范围
//--------------------
#include<stdio.h>

int main(){
	//char x = '5';
	//printf("%d\n",x-'0');
	//printf("%c\n",x+32);
	double a = 300.126345;
	double b = 300.126445;
	printf("a = %.15lf\n",a);
	printf("a = %.15lf\n",a);
	return 0;
}

//----------------------------
					
		④ 空类型:空类型不能声明变量，但是有其他作用
			void 来表示,ubuntu中默认void类型占据1个字节，但是不同的系统void类型占据内存空间不确定，所以void类型通常不能用来声明变量
		⑤ 自定义类型:他是一种自定义复合数据类型
			举例来说：如果想要形容一个人的身高，使用整型数就能去形容一个人的身高
			如果想要形容一个具体的人：需要性别，年龄，身高，体重
				其中：性别可以使用char类型表示，‘F’女性，‘M’代表男性
					年龄可以使用int类型来表示
					身高和体重可以使用：浮点型数据或者整型数据来表示
				那么，现在就需要将以上4个类型的数据，自定义复合成一种数据类型，该数据类型，就属于自定义类型
			C语言中的自定义类型只有3种：结构体，联合体，枚举
			结构体使用:struct + 结构体类型名 来表示一个自定义类型
			联合体使用:union + 联合体类型名 来表示一个自定义类型
			枚举:enum + 枚举类型名来表示一个自定义类型
		⑥ 地址类型:存放内存地址的变量。内存地址，在计算机中，通常以16进制数出现，无论是什么类型的变量的内存地址，他的大小，总是固定的，32位系统为4个字节，64位系统为8个字节。
			所有的地址类型，都可以使用%p进行格式占位
			所有地址类型的变量，只能存放十六进制的地址数据，这个地址数据的来源：就是对一个变量取地址&
			关键在于，如何确定一个地址类型数据的数据类型
			首先，确定该地址上所存放的数据的类型，然后以该类型为地址变量的基础数据类型,然后在基础数据类型后面加上*号，最终形成一个完整的地址数据类型,我们把这样的一个存放了地址的变量，称为指针变量，简称为指针,我们把一个指针存放一个变量的地址的行为，称为指向某个变量的地址

			总结：对任意类型的变量，加上&操作后，该变量的数据类型就会因为&而多一个*
		在拥有一个数据的地址之后，我们总是希望能够访问到数据本身。
		首先，访问一个地址，然后对该地值使用取值符号(*),就能取出该地址上存放的数据
		一个&符，会让数据类型多一个*，一个取值符号(*),会让数据类型少一个*
		
//--------------------
#include<stdio.h>

int main(){
	int a = 5;
	printf("a的地址为:%p\n",&a);
	int* pa = &a;//pa指向变量a的地址，a是int类型，所以pa是int*类型
	int** ppa = &pa;//ppa指向了变量pa的地址，pa是int*类型，所以ppa是int**类型
	int*** pppa = &ppa;//pppa指向了变量ppa的地址，ppa是int**类型，所以pppa是int***类型
	

	printf("a = %d\n",***pppa);
	return 0;
}

//---------------------------
#include<stdio.h>

int main(){
	int a = 5;
	int c = 15;
	int* b = &a;
	//*b = 10;//*&a = 10 -> a = 10
	b = &c;

	//指针的作用，就是为了保证，在不同的{}之中，进行运行的数据是同一个数据

	//假设，b和a在不同的{}中，使用某些手段，让{1}中的b等于{2}中的a，这个时候更改b的值，a的值不会改变
	//但是反过来，让{1}中的b指向{2}中的a的地址，这个时候更改*b的值，其实就是在更改a的值

	printf("a = %d\n",a);
	return 0;
}


*/
/*
	变量的命名规则：
		① 不能以数字开头作为变量名
		② 不能以关键字作为变量名
		③ 可以使用_开头，为变量命名，_开头的变量，通常与没有_开头的变量有密切联系。例如
			在编写注册功能的时候，就会有两个账号的变量，一个账号为系统中存在的账号，一个账号为用户需要输入的账号，这两个账号我们就可以使用_进行区分
		④ 变量命名的时候，必须要有其特殊含义,其含义与其用法必须对应，必要的时候，可以在变量名后面再追加计量单位的名称。严禁使用拼音命名
		在一个变量拥有多重含义的时候，我们可以使用以下两种命名方式来表示具体含义。例如zhangsan的身高，李四的体重
		 	1：下划线命名法：int zhangsan_height_cm = 180
			2: 驼峰命名法：int lisiWeightKg = 50;
*/
/*
	gcc 整个编译流程:一共分为以下4个步骤 gcc + 带编译文件名
		例如想要编译的是demo.c , gcc demo.c
		① 预处理阶段:gcc -E demo.c -o demo.i,代表，从与处理阶段开始执行，做到预处理阶段
			预处理demo.c,并生成demo.i
			1：头文件展开
				头文件中拥有许多函数的声明，函数的定义不在头文件中，函数的定义全都在库文件中
			2：简单宏替换
				宏：使用语法#define + 宏的名字 + 实际内容,宏简单的理解成实际内容的别名
				将 “宏的名字” 在预处理阶段简单的替换成 “实际内容”
				为什么叫做简单宏替换：因为宏替换的时候，永远不会考虑运算优先级问题
				还有一种宏叫做带参宏：
					#define + 宏的名字(参数) + 与参数挂钩的实际内容
				typedef:他是一个关键字，用来为一个数据类型取别名的操作
				typedef和#define的区别：#define会将宏替换成内容，所以实际参与编译的是内容，而typedef只是将内容取个别名，所以实际参与编译的是别名，只不过编译会将别名当做内容来编译
			
/*				
//----------------------------------
#include<stdio.h>
	
#define PI 3.1415926
#define FUNC(x) ((x)*(x))

#define ooi int

typedef long long int lli;

int main(){	
	long long int a = 5;
	lli b = 10;
	printf("%d\n",FUNC(3+3));
	return 0;
}
//-----------------------------------
				
			3：去注释
			4：上标记
		② 编译阶段:
		③ 汇编阶段:
		④ 链接阶段:
*/

//--------------第二天补的内容	-------------		
/*
	demo.c
	预处理阶段:gcc -E demo.c -o demo.i
		1:展开头文件
		2:简单宏替换
		3:去注释，注释有两种形式
			1/ 行注释，使用，//代表这一行的代码都属于注释
			2/ 段注释，使用/ * * /，被/ *扩起来的所有代码都属于注释

		4:上标记，为每一行的代码，标记上他在源文件中的行号
	编译阶段: gcc -S demo.c -o demo.s
		从预处理开始，只做到编译阶段
		编译阶段是整个编译过程的核心阶段，他会分析代码的词义，语义及语法结构，如果发现任何错误，都会终止编译，并且抛出错误。所以，整个编译过程中，只有编译阶段，会出现错误
		编译阶段会将语法正确的代码编译成汇编语言。汇编语义是一个指针针对内存操作的语言。系统底层的，几个操控驱动的函数，都是由汇编语言直接写成的。
	汇编阶段:gcc -c demo.s -o demo.o
		从预处理开始执行，只执行到汇编阶段
		所有库函数，我们ubuntu中是找不到源码的，因为所有的库函数都是以.o二进制文件的形式存在于库文件当中
		将汇编语言汇编成计算机能够识别的二进制语言
	链接阶段：gcc demo.o -o demo(可执行文件)
		将.o二进制文件，链接上动态库与静态库(包含了绝大部分的库函数的.o文件)
	举例来说：一个简单的程序的.o文件大小在1.2kb左右，但是生成的可执行文件有8.6kb左右，这多出来的7.4kb就是链接的动态库与静态库
	某一些库函数，他的库在编译阶段并不会默认链接到当前.o文件，此时，在编译的时候必须手动链接，在编译的最后加上 -l库名
	如何自己封装库文件:使用shell指令:ar crv lib库名.a + 等待封装的.o文件，如果有多个.o文件封装在一个库中，使用空格隔开
	库名为a的情况下
	也就是: ar crv liba.a -o demo.o
*/
