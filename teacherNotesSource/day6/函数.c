#include<stdio.h>

int main(){
/*
	int i = 0,j = 0;
	for(i=0;i<5;i++){
		for(j=0;j<5-i;j++){
			printf(" ");
		}
		for(j=0;j<i+1;j++){
			printf("* ");
		}
		printf("\n");
	}
	由于，想要输出不同层数的三角形的时候，奇迹上，整段代码中，只有5这个数字发生改变，所以，我们考虑将这段代码封装成一个功能模块，然后为该功能模块提供一个修改数据的接口，这个接口就是专门用来修改三角形层数。
	这样一来，无论我想要打印n次m层的三角形，只需要调用n次该功能模块，并且每一次调用的时候，准确的从接口处确定层数m的值即可
*/
	int n = 5;//n依靠参数导入
	int i = 0;
	int res = 0;
	for(int i=0;i<n;i++){
		res = res + i;
	}
	return 0;
}
/*
	我们把，这个封装了一整段代码，并且实现某个功能的模块，就称为函数，为函数提供数据导入功能的接口，我们称为函数的参数
	注意：当函数封装成功之后，该函数模块就成了一个暗箱，内部的所有数据，外部不能直接修改，也不能直接获取。想要修改函数内部的数据，只能通过名为参数的接口。想要获得内部的数据，只能通过名为返回值的接口
	
//------------------------
#include<stdio.h>

int func(int n){
	int i = 0;
	int res = 0;
	for(i=0;i<=n;i++){
		res = res + i;
	}
	return res;//任何函数，一旦遇到return，函数将会直接结束，并且将return后面的数据赋值给 函数的表达式
}

int main(){
	int num = 0;
	scanf("%d",&num);
	while(getchar()!=10);
	int res = func(num);
	int ret = printf("res = %d\n",res);
	printf("ret = %d\n",ret);
	return 0;
}

//-------------------------------------
*/
/*
	以上说到的2点就是函数3要素中的2个要素
		① 函数名
		② 函数参数(外部用来修改内部数据的接口)
		③ 函数返回值(内向外部输出输出的接口)
	函数与变量一样，在使用之前必须声明，但是函数和变量不一样的地方在于，函数在使用之前，必须定义
	如何声明及定义一个函数：
		声明部分：函数返回值类型 + 函数名(函数具体需要的参数，也就是函数的参数列表),注意，参数列表必须是声明变量的形式
		定义部分：在函数声明部分之后加上{},{}内的就是函数的定义部分
*/
/*
	调用一个函数，总是出于以下3种目的
		① 仅仅实现某一个功能(例如，在函数中打印一个n层三角形)
		② 仅仅计算某种运算的结果(使用函数计算1～n之和)
		③ 同时实现功能和计算结果:例如printf
*/
/*
	函数返回值的应用：
		函数的返回值可以包含多种多样的含义，并不一定是某种运算的运算结果，也可以是某种功能在运行当中，判断是否运行成功的标识。
		比方说，有如下函数，寻找6到10之内，是否拥有质数。这个函数的它就属于第③调用目的，功能为判断是否有质数，结果寻找到的质数个数。
		再比方说，有如下函数，判断某一个数是否为质数。这个函数也属于第三种调用目的，功能为判断该数是否是质数，结果就应该是判断的结果，不是质数，函数返回值为0。
*/
/*
	关于函数参数的应用
	由于函数的参数导入的过程是一个赋值的过程，所以就会产生一个比较麻烦的结果，在函数内部，改变参数的值，函数外部的参数不会改变
	我们把函数内部的参数称为函数的形参，函数外部的参数称为函数的实参，参数的传递过程(导入过程)，本质上是将实参的值赋值给形参，所以形参和实参是两个完全不同的个体数据，只不过数值是一样的。所以当形参发生改变的时候，实参不会有任何的变化
	很多时候，我们的目的就是将实参传入函数，通过某些特定规则改变实参的值，但是实参进入函数的方式只能是通过形参，然后形参的改变又不会影响到实参的值，为了解决这个问题，我们有以下两种解决方案。
		① 当形参发生改变之后，函数结束之前，我们将形参返回，并在外部使用实参去接受函数返回的形参
			但是，这种方式存在明显的缺点，就是当改变的形参不止1个的时候，但是返回值又只能返回1个数据，所以导致不能保证2组形参和实参的同步性。所以这个时候，我们就会采用第二中方式，来确保形参和实参的同步性
		② 将实参的地址传递给形参，所以形参本质上就是实参的地址，对形参取值，本质上就是对实参的地址取值，取出来的自然就是实参。
		
//-----------------------------
#include<stdio.h>

void func(int* pa,int* pb){
	*pa = 10;
	*pb = 50;
	return ;
}

int main(){
	int a = 5;
	int b = 20;
	
	//int* pa = &a;
	//*pa = 10;
	//a = 10	

	func(&a,&b);
	printf("a = %d,b = %d\n",a,b);
	return 0;
}
//-----------------------------------------
#include<stdio.h>

int main(){
	int a = 5;
	int* pa = &a;

	//无论一个指针指向多大的内存空间，该指针拥有只能指向这段内存空间的首字节地址，简称首地址

	return 0;
}
//------------------------------------------------------

	函数使用过程当中，一共有3个难点。
		① 函数返回值的设计，也就是需要确定函数返回值的意义
		② 保证实参与形参的同步性
		③ 当有多重函数嵌套调用的时候，一定要认清当前函数到底完成的是什么功能，以及当前函数的参数到底是从何处传递进来的并且当前函数的返回值到底要传递到何处
*/
/*
	在函数传参的过程中，我们人为规定，如果传入的参数，在函数内部会发生改变，那么就必须传指针。如果传入的参数在函数内部不会发生改变，就必须传普通数据
*/


//-------------------练习----------------------
/*
	封装一个函数，函数功能，判断导入的参数是否为质数。
	然后在主函数中，调用该函数实现功能，计算1~100之中，所有质数的和
*/
#include<stdio.h>

int func(int num){
	int i = 0;
	int count = 0;
	for(i=1;i<=num;i++){
		if(num%i==0){
			count++;
		}
	}
	return (count==2)?num:0;
}

int main(){
	int i = 0;
	int res = 0;
	//int ret = 0;
	for(i=1;i<=100;i++){
		res = res + func(i);
	}
	printf("res = %d\n",res);
	return 0;
}
//-----------------------
/*
	封装函数，实现功能，该函数会自动统计自身被调用的次数。
	然后在主函数中，调用该函数若干次之后，打印出该函数被调用的次数
*/

#include<stdio.h>

void func(int* pcount){
	(*pcount)++;
}

int main(){
	int count = 0;
	func(&count);
	printf("函数总共调用了%d次\n",count);
	return 0;
}
/*
	这样的一个函数记数功能，在之后的学习当中会经常被使用：
		假设 系统中存在一个容器，当调用insert函数的时候，会通过某种逻辑，向该容器中，添加一个数据。当调用remove函数的时候，同样会通过某种逻辑，从该容器中移除一个数据。
		所以，当调用insert的时候，记数变量count++，remove的时候记数变量count--
*/
//----------------------
/*
	编写一个注册登录系统：
		首先明确一件事情：所有注册成功的账号和密码都会分别保存在一个long long int 的nameDB 和 pswdDB当中，如何保存呢？这里限制输入的账号和密码只能是3位整型数
		举例说明，当输入的账号 name = 123的时候，那么就应该将name保存到nameDB中的第0个位置上，保存形式就是nameDB = 1230,当第二次注册账号成功后,比方说name = 456,那么就应该将 name = 456 保存到nameDB中的第1个位置上去，也就是说nameDB = 12304561
		密码保存方式同理

		基本要求：
			注册的时候，当用户输入想要注册的账号之后，首先判断nameDB中是否已经存在该账号，如果存在则注册失败，不存在则注册成功
			登录的时候，当用户输入想要登录的账号之后，首先判断nameDB是否存在该账户，如果存在，则继续输入密码，不存在则登录失败
			密码还需要判断是否正确

		进阶要求：登录时，账号允许无限次错误。密码如果输入错误3次以上，再次输入密码的时候要求输入验证码，验证码为随机生成的4位整型数，错误6次以上直接退出程序(验证码错误也算作密码错误)
 		分析：①注册函数②登录函数③查找账号函数
*/
#include<stdio.h>

typedef long long int lli;

int find_data(int name,lli nameDB){
	int i = 0;
	for(i=nameDB;i>0;i/=10000){//12304561
		if(name == i%10000/10){
			return i%10;
		}
	}
	return -1;
}

void regist(lli* nameDB,lli* pswdDB,int* len){
	int name = 0,pswd = 0;
	printf("请输入账号:");
	scanf("%d",&name);
	while(getchar()!=10);
	//查看name在nameDB中是否存在
	int res = find_data(name,*nameDB);
	if(res >= 0){
		printf("该账号已存在\n");
		return ;
	}
	*nameDB = *nameDB*10000 + name*10 + *len;
	printf("请输入密码:");
	scanf("%d",&pswd);
	while(getchar()!=10);
	*pswdDB = *pswdDB*10000 + pswd*10 + *len;
	(*len)++;
}

int login(lli nameDB,lli pswdDB){
	int name = 0,pswd = 0;
	printf("请输入账号:");
	scanf("%d",&name);
	while(getchar()!=10);
	int res = find_data(name,nameDB);
	if(res == -1){
		printf("该账号不存在\n");
		return 0;
	}
	printf("请输入密码:");
	scanf("%d",&pswd);
	while(getchar()!=10);
	pswd = pswd*10 + res;
	int i = 0;
	for(i=pswdDB;i>0;i/=10000){
		if(pswd == i%10000){
			return 1;
		}
	}
	return 0;
}

int main(){
	lli nameDB = 0;
	lli pswdDB = 0;
	int len = 0;
	int ch = 0;
	int res = 0;
	while(1){
		printf("1:注册\n");
		printf("2:登录\n");
		printf("3:查看数据库\n");
		printf("请选择");
		scanf("%d",&ch);
		while(getchar()!=10);
		switch(ch){
			case 1:
				regist(&nameDB,&pswdDB,&len);
				break;
			case 2:
				res = login(nameDB,pswdDB);
				if(res == 1){
					printf("登录成功\n");
				}
				break;
			case 3:
				printf("nameDB = %lld\n",nameDB);
				printf("pswdDB = %lld\n",pswdDB);
				break;
			default:
				break;
		}
	}
	return 0;
}
